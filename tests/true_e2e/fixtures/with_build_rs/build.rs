//! Build script that generates version info and a greeting function.
//!
//! This demonstrates common build.rs patterns used in real projects:
//! - writing generated Rust to OUT_DIR
//! - using Cargo-provided env vars
//! - emitting rerun-if-* directives

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Get the output directory from cargo
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("generated.rs");

    // Generate version info from environment
    let version = env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "unknown".to_string());
    let build_timestamp = chrono_like_timestamp();

    // Generate the Rust code
    let generated_code = format!(
        r#"// Auto-generated by build.rs - do not edit!

/// Returns version info generated at build time
pub fn version_info() -> &'static str {{
    "{version}"
}}

/// Returns the build timestamp
pub fn build_timestamp() -> &'static str {{
    "{build_timestamp}"
}}

/// A greeting generated at build time
pub fn generated_greeting() -> &'static str {{
    "Hello from build.rs generated code!"
}}

/// Demonstrates that build.rs ran successfully
pub const BUILD_RS_RAN: bool = true;
"#,
        version = version,
        build_timestamp = build_timestamp,
    );

    // Write the generated file
    fs::write(&dest_path, generated_code).expect("Failed to write generated.rs");

    // Tell cargo to rerun if build.rs changes
    println!("cargo:rerun-if-changed=build.rs");

    // Re-run if version changes (should be stable for this fixture)
    println!("cargo:rerun-if-env-changed=CARGO_PKG_VERSION");
}

/// Simple timestamp without external dependencies.
fn chrono_like_timestamp() -> String {
    // Static string for reproducibility in tests.
    "2026-01-19T00:00:00Z".to_string()
}

